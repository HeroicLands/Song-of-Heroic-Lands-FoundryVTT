/*
 * This file is part of the Song of Heroic Lands (SoHL) system for Foundry VTT.
 * Copyright (c) 2024-2025 Tom Rodriguez ("Toasty") â€” <toasty@heroiclands.com>
 *
 * This work is licensed under the GNU General Public License v3.0 (GPLv3).
 * You may copy, modify, and distribute it under the terms of that license.
 *
 * For full terms, see the LICENSE.md file in the project root or visit:
 * https://www.gnu.org/licenses/gpl-3.0.html
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

export class MissileWeaponStrikeModeItemData extends StrikeModeItemData {
    /** @inheritdoc */
    static metadata = Object.freeze(
        foundry.utils.mergeObject(
            super.metadata,
            {
                name: "missilestrikemode",
                locId: "MISSLESTRIKEMODE",
                label: "TYPES.Item.missilestrikemode",
                labelPlural: "TYPES.Item.missilestrikemodePl",
                iconCssClass: "fas fa-bow-arrow",
                img: "systems/sohl/assets/icons/longbow.svg",
                sheet: "systems/sohl/templates/item/missilestrikemode-sheet.html",
                nestOnly: true,
                group: "missile",
                effectKeys: {},
                schemaVersion: "0.5.6",
            },
            { inplace: false },
        ),
    );

    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            projectileType: new fields.StringField({
                initial: ProjectileGearItemData.SUBTYPE.NONE,
                required: true,
                choices: Utility.getChoicesMap(
                    ProjectileGearItemData.SUBTYPE,
                    "SOHL.PROJECTILEGEAR.SUBTYPE",
                ),
            }),
        });
    }

    getIntrinsicActions(_data = this, defaultAction = null, actions = []) {
        return super.getIntrinsicActions(
            _data,
            defaultAction,
            Utility.uniqueActions(
                actions,
                [CombatTestResult.TEST_TYPE.MISSILEATTACK].map(
                    (a) => CombatTestResult.testTypes[a],
                ),
            ),
        );
    }

    async attackTest(speaker, actor, token, character, scope = {}) {
        scope.mlMod = Utility.deepClone(this.$attack);
        scope.testType = CombatTestResult.TEST_TYPE.MISSILEATTACK;
        scope.title = _l("{weapon} {strikeModeName} Block Test", {
            weapon: this.item.nestedIn.name,
            strikeModeName: this.name,
        });
        return await CONFIG.SOHL.class.SuccessTestResult.createMacroTest(
            speaker,
            actor,
            token,
            character,
            scope,
        );
    }

    prepareBaseData() {
        super.prepareBaseData();
        this.$defense.block.setDisabled(_l("No Blocking Allowed"), "NoBlk");
        this.$defense.counterstrike.setDisabled(
            _l("No Counterstrike Allowed"),
            "NoCX",
        );
    }
}
